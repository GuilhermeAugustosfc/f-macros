'use strict';

var util = require('util');
var constant = require('./constant.cjs.js');
var fs = require('fs-extra');
var path = require('path');
var sdk = require('@module-federation/sdk');

// lib-polyfill.js: include core-js，@babel/runtime，@swc/helpers，tslib.
// lib-react.js: include react，react-dom.
// lib-router.js: include react-router，react-router-dom，history，@remix-run/router.
// lib-lodash.js: include lodash，lodash-es.
// lib-antd.js: include antd.
// lib-arco.js: include @arco-design/web-react.
// lib-semi.js: include @douyinfe/semi-ui.
// lib-axios.js: include axios.
var SPLIT_CHUNK_MAP = {
    REACT: 'react',
    ROUTER: 'router',
    LODASH: 'lib-lodash',
    ANTD: 'lib-antd',
    ARCO: 'lib-arco',
    SEMI: 'lib-semi',
    AXIOS: 'lib-axios'
};
var SHARED_SPLIT_CHUNK_MAP = {
    react: SPLIT_CHUNK_MAP.REACT,
    'react-dom': SPLIT_CHUNK_MAP.REACT,
    'react-router': SPLIT_CHUNK_MAP.ROUTER,
    'react-router-dom': SPLIT_CHUNK_MAP.ROUTER,
    '@remix-run/router': SPLIT_CHUNK_MAP.ROUTER,
    lodash: SPLIT_CHUNK_MAP.LODASH,
    'lodash-es': SPLIT_CHUNK_MAP.LODASH,
    antd: SPLIT_CHUNK_MAP.ANTD,
    '@arco-design/web-react': SPLIT_CHUNK_MAP.ARCO,
    '@douyinfe/semi-ui': SPLIT_CHUNK_MAP.SEMI,
    axios: SPLIT_CHUNK_MAP.AXIOS
};
function autoDeleteSplitChunkCacheGroups(mfConfig, splitChunks) {
    if (!mfConfig.shared) {
        return;
    }
    if (!splitChunks || !(splitChunks === null || splitChunks === void 0 ? void 0 : splitChunks.cacheGroups)) {
        return;
    }
    var arrayShared = Array.isArray(mfConfig.shared) ? mfConfig.shared : Object.keys(mfConfig.shared);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = arrayShared[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var shared = _step.value;
            var splitChunkKey = SHARED_SPLIT_CHUNK_MAP[shared];
            if (!splitChunkKey) {
                continue;
            }
            if (splitChunks.cacheGroups[splitChunkKey]) {
                delete splitChunks.cacheGroups[splitChunkKey];
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return splitChunks;
}

function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var addDataFetchExpose = function(exposes, key, filepath) {
    var suffix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : '';
    if (!fs.existsSync(filepath)) {
        return false;
    }
    var dataFetchKey = key === '.' ? "./".concat(constant.DATA_FETCH_IDENTIFIER).concat(suffix) : "".concat(key, ".").concat(constant.DATA_FETCH_IDENTIFIER).concat(suffix);
    if (exposes[dataFetchKey] && exposes[dataFetchKey] !== filepath) {
        throw new Error("data fetch key ".concat(dataFetchKey, " already exists, please modify this expose key, do not end with '").concat(constant.DATA_FETCH_IDENTIFIER, "' or '").concat(constant.DATA_FETCH_CLIENT_SUFFIX, "'"));
    }
    exposes[dataFetchKey] = filepath;
    return dataFetchKey;
};
var addExcludeDtsSuffix = function(filepath) {
    return "".concat(filepath, "?exclude-mf-dts=true");
};
function addDataFetchExposes(exposes, isServer) {
    if ((typeof exposes === "undefined" ? "undefined" : _type_of(exposes)) !== 'object' || Array.isArray(exposes)) {
        return;
    }
    if (Object.keys(exposes).length === 0) {
        return;
    }
    var tempDataFetchFilepath = path.resolve(process.cwd(), "node_modules/".concat(sdk.TEMP_DIR, "/data-fetch-fallback.ts"));
    var content = "export const fetchData=()=>{throw new Error('should not be called')};";
    fs.ensureDirSync(path.dirname(tempDataFetchFilepath));
    fs.writeFileSync(tempDataFetchFilepath, content);
    Object.keys(exposes).forEach(function(key) {
        var expose = exposes[key];
        if (typeof expose !== 'string') {
            return;
        }
        var absPath = path.resolve(process.cwd(), expose);
        var dataFetchPath = "".concat(absPath.replace(path.extname(absPath), ''), ".").concat(constant.DATA_FETCH_IDENTIFIER, ".ts");
        var dataFetchClientPath = "".concat(absPath.replace(path.extname(absPath), ''), ".").concat(constant.DATA_FETCH_IDENTIFIER, ".client.ts");
        var dateFetchClientKey = addDataFetchExpose(exposes, key, dataFetchClientPath, constant.DATA_FETCH_CLIENT_SUFFIX);
        if (!isServer && dateFetchClientKey) {
            exposes[dateFetchClientKey.replace(constant.DATA_FETCH_CLIENT_SUFFIX, '')] = addExcludeDtsSuffix(tempDataFetchFilepath);
            return;
        }
        var dataFetchKey = addDataFetchExpose(exposes, key, dataFetchPath);
        if (dataFetchKey && fs.existsSync(dataFetchClientPath)) {
            exposes["".concat(dataFetchKey).concat(constant.DATA_FETCH_CLIENT_SUFFIX)] = addExcludeDtsSuffix(tempDataFetchFilepath);
        }
    });
}

function isRegExp(target) {
    return util.types.isRegExp(target);
}

exports.DEFAULT_ASSET_PREFIX = constant.DEFAULT_ASSET_PREFIX;
exports.addDataFetchExposes = addDataFetchExposes;
exports.autoDeleteSplitChunkCacheGroups = autoDeleteSplitChunkCacheGroups;
exports.isRegExp = isRegExp;
